<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Image → Shader</title>
<style>
  :root{
    --bg:#0b1220; --card:#0f1724; --panel:#071029; --muted:#93a0b5; --accent:#1f6feb;
    --gap:12px; --radius:10px;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family:Inter,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    background:var(--bg);
    color:#e6eef6;
    padding:16px;
  }

  .layout{display:flex;flex-direction:column;gap:16px}
  @media(min-width:960px){ .layout{flex-direction:row} }

  .panel{
    background:linear-gradient(180deg,var(--card),#081226);
    padding:12px;
    border-radius:var(--radius);
    box-shadow:0 6px 18px rgba(0,0,0,.45);
  }

  .left{display:flex;flex-direction:column;gap:12px;min-width:280px}
  .right{display:flex;flex-direction:column;gap:8px;flex:1}

  label{display:flex;flex-direction:column;gap:6px;font-size:13px;color:var(--muted)}
  input[type=file], select, button, textarea{
    padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,.06);
    background:var(--panel);color:#e6eef6;font-size:14px;
  }

  .controls{display:flex;gap:8px;flex-wrap:wrap}
  button{cursor:pointer;border:none}
  button:disabled{opacity:.35;cursor:not-allowed}

  .preview-wrap{display:flex;flex-direction:column;align-items:center;gap:8px}
  img#preview{image-rendering:pixelated;border-radius:6px;border:1px solid rgba(255,255,255,.04);background:#06111b}

  textarea#editor{
    width:100%;min-height:360px;background:#021024;color:#e6eef6;padding:12px;border-radius:8px;border:1px solid rgba(255,255,255,.03);
    font-family:SFMono-Regular,Menlo,Monaco,monospace;font-size:13px;resize:vertical;white-space:pre-wrap;
  }

  .meta{font-size:12px;color:var(--muted);display:flex;justify-content:space-between;gap:8px;align-items:center}
  .small{font-size:12px;color:var(--muted)}

  @media(min-width:960px){ .left{width:360px;flex:0 0 360px} }

  .row{display:flex;gap:8px;align-items:center}
</style>
</head>
<body>

<div class="layout">
  <div class="panel left">
    <label>
      Select image
      <input id="file" type="file" accept="image/*">
    </label>

    <div class="row" style="gap:10px">
      <label style="flex:1">
        Target size
        <select id="size">
          <option value="16">16 × 16</option>
          <option value="32">32 × 32</option>
          <option value="64">64 × 64</option>
        </select>
      </label>

      <label style="width:150px">
        Output target
        <select id="target">
          <option value="editor">Shader Editor</option>
          <option value="shadertoy">Shadertoy</option>
        </select>
      </label>
    </div>

    <label id="versionLabel">
      GLSL version (Shader Editor only)
      <select id="versionSelect">
        <option value="300">GLES 300 ES (#version 300 es)</option>
        <option value="100">GL 100 (legacy)</option>
      </select>
    </label>

    <div class="controls">
      <button id="generateBtn" disabled>Generate</button>
      <button id="downloadBtn" disabled>Download .frag</button>
      <button id="copyBtn" disabled>Copy</button>
      <button id="downloadPreviewBtn" disabled>Download PNG</button>
    </div>

    <div class="preview-wrap" style="margin-top:6px">
      <div style="width:256px;height:256px;display:flex;align-items:center;justify-content:center">
        <img id="preview" width="256" height="256" alt="preview">
      </div>
      <div class="small">Upscaled preview</div>
    </div>
  </div>

  <div class="panel right">
    <div class="meta">
      <div class="small">Shader — generated code</div>
      <div class="small">Size: <span id="selSize">16×16</span></div>
    </div>

    <textarea id="editor" spellcheck="false">Upload an image to generate shader...</textarea>
  </div>
</div>

<canvas id="work" style="display:none"></canvas>

<script>
const fileInput = document.getElementById('file');
const sizeSel = document.getElementById('size');
const targetSel = document.getElementById('target');
const versionSelect = document.getElementById('versionSelect');
const versionLabel = document.getElementById('versionLabel');

const generateBtn = document.getElementById('generateBtn');
const downloadBtn = document.getElementById('downloadBtn');
const copyBtn = document.getElementById('copyBtn');
const downloadPreviewBtn = document.getElementById('downloadPreviewBtn');

const editor = document.getElementById('editor');
const preview = document.getElementById('preview');
const work = document.getElementById('work');
const selSize = document.getElementById('selSize');

let currentImage = null;
let lastImageData = null;

fileInput.addEventListener('change', (e)=>{
  const f = e.target.files && e.target.files[0];
  if(!f){ disableAll(); return; }
  if(!f.type.startsWith('image/')){ alert('Please select an image file.'); disableAll(); return; }
  const url = URL.createObjectURL(f);
  const img = new Image();
  img.crossOrigin = "anonymous";
  img.onload = ()=>{
    currentImage = img;
    generateBtn.disabled = false;
    renderPreviewScaled();
  };
  img.onerror = ()=>{ alert('Failed to load image.'); disableAll(); };
  img.src = url;
});

sizeSel.addEventListener('change', ()=>{ selSize.textContent = sizeSel.value + '×' + sizeSel.value; if(currentImage) renderPreviewScaled(); });
targetSel.addEventListener('change', ()=>{ if(targetSel.value === 'shadertoy'){ versionSelect.disabled = true; versionLabel.style.opacity = 0.6; } else { versionSelect.disabled = false; versionLabel.style.opacity = 1; } });

function disableAll(){
  generateBtn.disabled = true;
  downloadBtn.disabled = true;
  downloadPreviewBtn.disabled = true;
  copyBtn.disabled = true;
  preview.src = '';
  editor.value = 'Upload an image to generate shader...';
  lastImageData = null;
}

function renderPreviewScaled(){
  const N = parseInt(sizeSel.value,10);
  const img = currentImage;
  work.width = N; work.height = N;
  const ctx = work.getContext('2d');
  ctx.imageSmoothingEnabled = false;

  const arImg = img.width / img.height;
  let sx=0, sy=0, sw=img.width, sh=img.height;
  if(arImg > 1){
    sh = img.height;
    sw = Math.round(sh * arImg);
    sx = Math.round((img.width - sw)/2);
  } else {
    sw = img.width;
    sh = Math.round(sw / arImg);
    sy = Math.round((img.height - sh)/2);
  }
  sx = Math.max(0, Math.min(sx, img.width-1));
  sy = Math.max(0, Math.min(sy, img.height-1));

  ctx.clearRect(0,0,N,N);
  ctx.drawImage(img, sx, sy, sw, sh, 0, 0, N, N);

  const up = document.createElement('canvas');
  const scale = Math.floor(256 / Math.max(N,1));
  up.width = N * scale; up.height = N * scale;
  const upCtx = up.getContext('2d');
  upCtx.imageSmoothingEnabled = false;
  upCtx.drawImage(work, 0, 0, up.width, up.height);
  preview.src = up.toDataURL('image/png');

  lastImageData = ctx.getImageData(0,0,N,N);
}

generateBtn.addEventListener('click', ()=>{
  if(!lastImageData){ alert('Image not ready.'); return; }
  const N = parseInt(sizeSel.value,10);
  const target = targetSel.value;
  const version = versionSelect.value;
  const shaderText = makeShaderText(lastImageData, N, N, target, version);
  editor.value = shaderText;
  downloadBtn.disabled = false;
  downloadPreviewBtn.disabled = false;
  copyBtn.disabled = false;

  downloadBtn.onclick = ()=>downloadTextAsFile(shaderText, `image_shader_${N}x${N}_${target}${target==='editor'?('_v'+version):''}.frag`);
  downloadPreviewBtn.onclick = ()=>downloadCanvasAsPng(lastImageData, N, `preview_${N}x${N}.png`);
});

// Better copy handler with fallback for insecure/older environments
copyBtn.addEventListener('click', async () => {
  const text = editor.value || '';
  // helper to show success briefly
  function flashCopySuccess() {
    const prev = copyBtn.textContent;
    copyBtn.textContent = 'Copied ✓';
    setTimeout(() => { copyBtn.textContent = prev; }, 1200);
  }

  // Try the modern async Clipboard API first (requires secure context)
  if (navigator.clipboard && navigator.clipboard.writeText) {
    try {
      await navigator.clipboard.writeText(text);
      flashCopySuccess();
      return;
    } catch (e) {
      // fall through to fallback method
      // console.warn('navigator.clipboard failed, falling back:', e);
    }
  }

  // Fallback: create a temporary textarea, select and execCommand('copy')
  try {
    const ta = document.createElement('textarea');
    ta.value = text;
    // Prevent scrolling to bottom and keep it off-screen
    ta.style.position = 'fixed';
    ta.style.left = '-9999px';
    ta.style.top = '0';
    document.body.appendChild(ta);
    ta.focus();
    ta.select();

    const ok = document.execCommand('copy');
    document.body.removeChild(ta);

    if (ok) {
      flashCopySuccess();
      return;
    } else {
      throw new Error('execCommand returned false');
    }
  } catch (err) {
    // Last resort: select the editor content and ask the user to press Ctrl/Cmd+C
    try {
      editor.focus();
      editor.select();
    } catch (e) {}
    alert('Copy failed — please press Ctrl+C (Cmd+C on Mac) to copy manually.');
  }
});

function downloadTextAsFile(text, filename){
  const b = new Blob([text], {type:'text/plain'});
  const url = URL.createObjectURL(b);
  const a = document.createElement('a');
  a.href = url; a.download = filename; document.body.appendChild(a);
  a.click(); a.remove(); URL.revokeObjectURL(url);
}

function downloadCanvasAsPng(imageData, N, filename){
  const tmp = document.createElement('canvas');
  tmp.width = N; tmp.height = N;
  tmp.getContext('2d').putImageData(imageData,0,0);
  tmp.toBlob((blob)=>{
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = filename; document.body.appendChild(a);
    a.click(); a.remove(); URL.revokeObjectURL(url);
  }, 'image/png');
}

/*
  For GL100: arrays with explicit large constructors are not supported in many editors.
  We generate a fallback lookup function `vec4 getPixel(int idx)` that returns each pixel via if-chain.
  This is verbose but compatible with legacy GLSL (GL 100).
*/

function makeShaderText(imgData, W, H, targetMode, versionFlag){
  const pixels = imgData.data;
  const total = W*H;
  const vals = [];
  for(let i=0;i<total;i++){
    const j = i*4;
    const r = (pixels[j]/255).toFixed(4);
    const g = (pixels[j+1]/255).toFixed(4);
    const b = (pixels[j+2]/255).toFixed(4);
    const a = (pixels[j+3]/255).toFixed(4);
    vals.push(`vec4(${r}, ${g}, ${b}, ${a})`);
  }

  // chunked string builder for readability in the generated shader
  const chunk = 8;
  const arrLines = [];
  for(let i=0;i<vals.length;i+=chunk){
    arrLines.push('  ' + vals.slice(i,i+chunk).join(', '));
  }

  if(targetMode === 'shadertoy'){
    // Shadertoy: use mainImage, built-ins (iResolution, iTime, iMouse)
    return `// Shadertoy-ready shader — size: ${W}x${H}
precision mediump float;

const int W = ${W};
const int H = ${H};
const int TOTAL = ${total};
${genPixelsArrayOrFallback(vals, total, /*forceFallback=*/false)}

vec4 samplePixel(ivec2 p){
  int x = clamp(p.x, 0, W-1);
  int y = clamp(p.y, 0, H-1);
  int idx = y * W + x;
  return getPixel(idx);
}

vec4 sampleUV(vec2 uv){
  uv = clamp(uv, 0.0, 1.0);
  int x = int(floor(uv.x * float(W)));
  // flip Y so texture (which is stored top-to-bottom) maps correctly to shader coords
  int y = int(floor((1.0 - uv.y) * float(H)));
  return samplePixel(ivec2(x,y));
}

void mainImage(out vec4 fragColor, in vec2 fragCoord){
  vec2 uv = fragCoord.xy / iResolution.xy;
  fragColor = sampleUV(uv);
}
`;
  } else {
    // Shader Editor mode: add uniforms resolution,time,touch
    const uniforms = `uniform vec2 resolution;\nuniform float time;\nuniform vec2 touch;\n`;
    if(versionFlag === '300'){
      return `#version 300 es
precision highp float;
${uniforms}
out vec4 fragColor;
const int W = ${W};
const int H = ${H};
const int TOTAL = ${total};
${genPixelsArrayOrFallback(vals, total, /*forceFallback=*/false)}

vec4 samplePixel(ivec2 p){
  int x = clamp(p.x, 0, W-1);
  int y = clamp(p.y, 0, H-1);
  int idx = y * W + x;
  return getPixel(idx);
}

vec4 sampleUV(vec2 uv){
  uv = clamp(uv, 0.0, 1.0);
  int x = int(floor(uv.x * float(W)));
  // flip Y so texture (which is stored top-to-bottom) maps correctly to shader coords
  int y = int(floor((1.0 - uv.y) * float(H)));
  return samplePixel(ivec2(x,y));
}

void main(){
  vec2 uv = gl_FragCoord.xy / resolution.xy;
  fragColor = sampleUV(uv);
}
`;
    } else {
      // GL 100 legacy: do NOT use array constructor initialization — use function fallback
      return `precision mediump float;
${uniforms}
const int W = ${W};
const int H = ${H};
const int TOTAL = ${total};
${genPixelsArrayOrFallback(vals, total, /*forceFallback=*/true)}

vec4 samplePixel(ivec2 p){
  int x = clamp(p.x, 0, W-1);
  int y = clamp(p.y, 0, H-1);
  int idx = y * W + x;
  return getPixel(idx);
}

vec4 sampleUV(vec2 uv){
  uv = clamp(uv, 0.0, 1.0);
  int x = int(floor(uv.x * float(W)));
  // flip Y so texture (which is stored top-to-bottom) maps correctly to shader coords
  int y = int(floor((1.0 - uv.y) * float(H)));
  return samplePixel(ivec2(x,y));
}

void main(){
  vec2 uv = gl_FragCoord.xy / resolution.xy;
  gl_FragColor = sampleUV(uv);
}
`;
    }
  }
}

// Helper: generate either a static const array (for contexts that accept it) OR a fallback function getPixel(idx).
// For GL100 we force fallback because many editors don't accept vec4[...] constructors.
function genPixelsArrayOrFallback(vals, total, forceFallback){
  // If not forcing fallback and total is small, try array initializer - but we still support fallback universally.
  // To be safe, produce a small array initializer for GLES300; for GL100 we MUST use fallback.
  if(!forceFallback){
    // produce a const vec4 pixels[...] array and a simple getPixel that indexes it.
    const arrLines = [];
    for(let i=0;i<vals.length;i+=8){
      arrLines.push('  ' + vals.slice(i,i+8).join(', '));
    }
    return `const vec4 pixels[TOTAL] = vec4[TOTAL](\n${arrLines.join(',\n')}\n);\n\nvec4 getPixel(int idx){\n  return pixels[idx];\n}\n`;
  } else {
    // fallback: generate a getPixel function with if-chain (compatible with GL100)
    // Build in chunks to avoid extremely long single string concatenations in some environments.
    let out = 'vec4 getPixel(int idx){\n';
    // Use a chain of if statements
    for(let i=0;i<vals.length;i++){
      out += `  if(idx==${i}) return ${vals[i]};\n`;
    }
    out += '  return vec4(0.0,0.0,0.0,0.0);\n}\n';
    return out;
  }
}

// Initialize
disableAll();
</script>
</body>
</html>
